"""Authentication logic for API keys."""

import hashlib
import secrets
from datetime import datetime
from typing import Optional

from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy.orm import Session

from handoffkit.api.database import get_db
from handoffkit.api.models.auth import APIKey

# Security scheme
security = HTTPBearer()


def generate_api_key() -> str:
    """Generate a secure API key.

    Returns:
        str: A secure, random API key starting with 'hk_'.
    """
    return f"hk_{secrets.token_urlsafe(32)}"


def hash_key(key: str) -> str:
    """Hash an API key for storage.

    Uses SHA-256 for deterministic hashing to allow database lookups.
    Since API keys are high-entropy (generated by secrets.token_urlsafe),
    fast hashing is secure enough (unlike user passwords).

    Args:
        key: The raw API key.

    Returns:
        str: The hashed key.
    """
    return hashlib.sha256(key.encode()).hexdigest()


def verify_key(plain_key: str, hashed_key: str) -> bool:
    """Verify an API key against a hash.

    Args:
        plain_key: The raw API key to verify.
        hashed_key: The expected hash.

    Returns:
        bool: True if the key matches the hash.
    """
    return secrets.compare_digest(hash_key(plain_key), hashed_key)


def verify_api_key_in_db(key: str, db: Session) -> Optional[APIKey]:
    """Verify key against database and return APIKey object if valid.

    Args:
        key: The raw API key.
        db: Database session.

    Returns:
        Optional[APIKey]: The APIKey object if valid and active, None otherwise.
    """
    key_hash = hash_key(key)
    api_key = db.query(APIKey).filter(APIKey.key_hash == key_hash).first()

    if api_key and api_key.is_active:
        return api_key
    return None


async def get_api_key(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    db: Session = Depends(get_db)
) -> APIKey:
    """FastAPI dependency to validate API key.

    Args:
        credentials: The Bearer token from the Authorization header.
        db: Database session.

    Returns:
        APIKey: The validated API key object.

    Raises:
        HTTPException: If key is invalid or inactive.
    """
    raw_key = credentials.credentials
    api_key = verify_api_key_in_db(raw_key, db)

    if not api_key:
        # We don't distinguish between "not found" and "inactive" for security
        # unless we explicitly want to return 403 for inactive
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid API key",
            headers={"WWW-Authenticate": "Bearer"},
        )

    if not api_key.is_active:
         raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="API key is inactive",
        )

    # Update last used timestamp
    # Note: In a high-concurrency environment, this might cause write contention.
    # For MVP, this is acceptable.
    api_key.last_used_at = datetime.utcnow()
    db.commit()

    return api_key
